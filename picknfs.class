<?
// vim:foldmethod=marker
include_once('osfi.class');

define('TRIGGERFILE','DM,PICKNFS,'); // modify as need to refer to trigger file
/*
  access pick using standard OSFI provided by D3
  specify host and port to connect to
  for best security, use localhost and secure tunnel if off box
  added quick option which can do CRUD only, connect with no credentials

*/
class PickNFS extends OSFI 
{
/* member variables {{{ */
  var $host = '';
  var $port = 0;
  var $queries = -1;
  var $qid;
/* }}} */

  function __construct($host, $port) { /* {{{ */

    OSFI::__construct();

    $this->host = $host;
    $this->port = $port;
    $this->connected = false;

    $this->queries = -1;
    $this->qid = getmypid().'.'.rand();

  }
/* }}} */

  function __destruct() { /* {{{ */

    if ($this->sock && $this->connected) {

// close execution locks
      foreach($this->locks as $lock => $r)
        $this->lock($tmp,0,$lock);

// close open files
      foreach($this->files as $fd => $r)
        $this->close($fd);

// close open selects
      foreach($this->selects as $fd => $r)
        $this->clearselect($fd);

// close open roots
      foreach($this->indexes as $fd => $r)
        $this->closeroot($fd);

    }

    OSFI::__destruct();

  }
/* }}} */

  function connect($user=null, $pass=null, $acct=null, $apsw=null) { /* {{{ */

    if ($this->sock === null) {
      $this->sock = socket_create(AF_INET,SOCK_STREAM,0);
      if (!$this->sock) die(socket_last_error().':'.socket_strerror((socket_last_error())));
    }

    if (!$this->sock) return false;
    if (!socket_connect($this->sock,$this->host,$this->port)) return false;

    $this->user = $user.AM.$user;
    $this->host = $this->host.VM.$this->port.VM.VM.'15'.SM;
    $this->acct = $acct;

    $this->connected = true;
    $login = false;
    $this->set_timeout(30,30);

    if ($user === null && $pass === null && $acct === null && $apsw === null) {
      $this->user = 'DM';
      $this->acct = 'DM';
      return true;
    }

    $this->open(0,TRIGGERFILE,$this->queries) or die(TRIGGERFILE." file not found\n");

    $this->use_queries("/LOGIN\xfb$user\xfb$pass\xfb$acct\xfb$apsw",$tmp) or die("PICKNFS queries could not be processed\n");
    if ($tmp != '')
      list($this->pib,$login) = array($tmp,true);

    return $login;

  }
/* }}} */

  function use_queries($stmt, &$rec)  /* {{{ */
  {

    $rec = '';
    if ($this->queries < 0) return false;

    if ($this->write($stmt,$this->queries,$this->qid))
      if ($this->read($rec,$this->queries,$this->qid)) 
        return $this->delete_item($this->queries,$this->qid);

    return false;
    
  }
/* }}} */

  function open($dict, $fname, &$fd)  /* {{{ */
  {
    if ($fname == '') return false; // must be valid

    if ($fname[strlen($fname)-1] != ',')
      $fname = "{$this->acct},$fname,"; // construct full path
    $fname = strtolower($fname); // make case insensitive

    if (isset($this->cache[$fname])) {
      $fd = $this->cache[$fname];
      return true;
    }

    $this->init(1,RP_OPEN);
    if (!$dict) $this->arg0 = RP_OPENDATA; // open data
    $this->append(NIL,$fname,VM,$this->host,$this->user,AM,SM,SM);

    if ($this->send())
     if ($this->get($tmp))
       if ($this->rtncd == RP_OK) {
         $fd = $this->file_count++;
         $this->files[$fd] = array('path'=>$fname, 'fcb'=>$this->prot0, 'dict'=>$dict, 'locks'=>array());
         $this->cache[$fname] = $fd;
         return true; 
       }

    return false;

  }
/* }}} */

  function close($fd)  /* {{{ */
  {

    if ($fd < 0) return false;
    else if (!isset($this->files[$fd])) return false;
    else if ($this->files[$fd] === null) return false;

    foreach($this->files[$fd]['locks'] as $ky => $id)
      $this->release($fd,$id);

    $this->init(2,RP_CLOSE);
    $this->prot0 = $this->files[$fd]['fcb'];
    if (!$this->files[$fd]['dict']) $this->arg0 = RP_OPENDATA; // close data portion

    if ($this->send())
      if ($this->get($tmp)) {
          unset($this->cache[$this->files[$fd]['path']]);
          $this->files[$fd] = null;
        }

    return true;
  }
/* }}} */

  function clearfile($fd) /* {{{ */
  {
    if ($fd < 0) return false;
    else if (!isset($this->files[$fd])) return false;
    else if ($this->files[$fd] === null) return false;

    $this->init(2,RP_CLEARFILE);
    $this->prot0 = $this->files[$fd]['fcb'];
    $this->append(NIL,SM);

    if ($this->send())
      if ($this->get($tmp))
        return true;

    return false;
  
  }
/* }}} */

  function read(&$rec, $fd, $id) /* {{{ */
  {

    if ($fd < 0) return false;
    else if (!isset($this->files[$fd])) return false;
    else if ($this->files[$fd] === null) return false;

    $this->init(3,RP_RETIX);
    $this->prot0 = $this->files[$fd]['fcb'];
    $this->append(NIL,$id,AM,SM);
    if ($this->send())
      if ($this->get($tmp))
        if ($this->rtncd == RP_OK) {

          $rec = substr($tmp,$this->strsz + (RP_ITEMHDRSZ - 2), $this->bfsz - RP_ITEMHDRSZ - $this->strsz); // return includes id and leading bytes and sentinels
          return true;
        }

    return false;
  }
/* }}} */

  function readu(&$rec, $fd, $id, &$locked) /* {{{ */
  {

    $locked = false;
    if ($fd < 0) return false;
    else if (!isset($this->files[$fd])) return false;
    else if ($this->files[$fd] === null) return false;


    $this->init(3,RP_RETIX);
    $this->prot0 = $this->files[$fd]['fcb'];
    $this->arg0 = 1; // update lock
    $this->append(NIL,$id,AM,SM);

    if ($this->send())
      if ($this->get($tmp)) {

        if ($this->rtncd == RP_LOCKED)
          $locked = true;
        else if ($this->rtncd == RP_OK) {
          $rec = substr($tmp,$this->strsz + (RP_ITEMHDRSZ - 2), $this->bfsz - RP_ITEMHDRSZ - $this->strsz);
          $this->files[$fd]['locks'][strtoupper($id)] = $id;
          return true;
        }

      }

    return false;
      
  }
/* }}} */
 
  function readv(&$rec, $fd, $id, $attr) /* {{{ */
  {

    if ($this->read($tmp, $fd, $id)) {
      $arr = MATPARSE($tmp);
      $rec = $arr[$attr];
      return true;
    }

    return false;

  }
/* }}} */
 
  function readvu(&$rec, $fd, $id, $attr, &$locked) /* {{{ */
  {

    if ($this->readu($tmp, $fd, $id, $locked)) {
      $arr = MATPARSE($tmp);
      $rec = $arr[$attr];
      return true;
    }

    return false;

  }
/* }}} */

  function write($rec, $fd, $id) /* {{{ */
  {

    if ($fd < 0) return false;
    else if (!isset($this->files[$fd])) return false;
    else if ($this->files[$fd] === null) return false;

    $this->init(6,RP_UPDITM);
    $this->arg0 = 0;
    $this->prot0 = $this->files[$fd]['fcb'];
    $this->append(NIL,$id,SM,SM);

    $this->bfsz = strlen($rec) + 3;

    if ($this->send($rec))
      if ($this->get($tmp)) {
        unset($this->files[$fd]['locks'][strtoupper($id)]);
        return true;
      }

    return false;
  }
/* }}} */

  function writeu($rec, $fd, $id) /* {{{ */
  {

    if ($fd < 0) return false;
    else if (!isset($this->files[$fd])) return false;
    else if ($this->files[$fd] === null) return false;

    $this->init(6,RP_UPDITM);
    $this->arg0 = 2; // keep locked
    $this->prot0 = $this->files[$fd]['fcb'];
    $this->append(NIL,$id,SM,SM);

    $this->bfsz = strlen($rec) + 3;
 
    if ($this->send($rec))
      if ($this->get($tmp))
        return true;

    return false;

  }
/* }}} */

  function _writev($rec, $fd, $id, $attr) /* {{{ */
/*
prep for writev
return record suiteable for writing
*/
  {
    if ($attr == 0)
      $tmp = $rec;
    else {
      if (!$this->read($tmp, $fd, $id))
        $tmp = '';

      if ($attr < 0) {
        if ($tmp == '')
          $tmp = $rec;
        else
          $tmp .= AM.$rec;
      } else {
        $arr = MATPARSE($tmp);
        MATPAD($arr,$attr);
        $arr[$attr] = $rec;
        $tmp = implode(AM,array_slice($arr,1));
      }

    }

    return $tmp;
  }
/* }}} */

  function writev($rec, $fd, $id, $attr) /* {{{ */
  {

    return $this->write($this->_writev($rec,$fd,$id,$attr),$fd,$id);

  }
/* }}} */

  function writevu($rec, $fd, $id, $attr) /* {{{ */
  {

    return $this->writeu($this->_writev($rec, $fd, $id, $attr),$fd,$id);

  }
/* }}} */

  function delete_item($fd, $id) /* {{{ */
  {
    if ($fd < 0) return false;
    else if (!isset($this->files[$fd])) return false;
    else if ($this->files[$fd] === null) return false;

    $this->init(6,RP_UPDITM);
    $this->prot0 = $this->files[$fd]['fcb'];
    $this->arg0 = 1;
    $this->append(NIL,$id,SM,SM);

    if ($this->send())
      if ($this->get($tmp))  {
        unset($this->files[$fd]['locks'][strtoupper($id)]);
        return true;
      }
    return false;
  }
/* }}} */

  function release($fd, $id) /* {{{ */
  {

    if ($fd < 0) return false;
    else if (!isset($this->files[$fd])) return false;
    else if ($this->files[$fd] === null) return false;

    $this->init(2,RP_RELEASE);
    $this->arg0 = 0;
    $this->prot0 = $this->files[$fd]['fcb'];
    $this->append(NIL,$id,SM);

    if ($this->send())
      if ($this->get($tmp)) {
        unset($this->files[$fd]['locks'][strtoupper($id)]);
        return true;
      }


    return false;

  }
/* }}} */

  function execute($tcl, &$cap = null, &$ret = null, $passlist = 0, $passitems = null, &$rtnlist = null, &$count = null)  /* {{{ */
  {
    if ($cap !== null) $cap = '';
    if ($ret !== null) $ret = '';
    if ($rtnlist !== null) $rtnlist = -1;
    if ($count !== null) $count = -1;

    if ($passlist > 0 && 
        isset($this->selects[$passlist-1]) && 
        isset($this->selects[$passlist-1]['fcb'])) {

      $tmp = array();
      while ($this->readnext($id,$passlist-1))
        $tmp[] = $id;
      $passitems = implode(AM,$tmp);
    }

    $stmt = "/EXECUTE2".SB.$tcl;
    if ($passitems !== null) $stmt .= SB.$passitems;

    if ($this->use_queries($stmt,$rec)) {

      $r = explode(SB,$rec);
      switch(count($r)) {
        case 1: 
          if ($cap === null) echo str_replace(AM,"\r\n",$r[0]); else $cap = $r[0]; 
          break;

        case 2: 
          if ($cap === null) echo str_replace(AM,"\r\n",$r[1]); else $cap = $r[1]; 
          if ($ret !== null) $ret = $r[0];
          break;

        case 3:
          if ($cap === null) echo str_replace(AM,"\r\n",$r[1]); else $cap = $r[1]; 
          if ($ret !== null) $ret = $r[0];
          $items = $r[2];

          if ($rtnlist !== null) {

            $rtnlist = $this->select_count++;
            $items = explode(AM,$items);
            $cnt = count($items);
            if ($count !== null) $count = $cnt;
            $this->selects[$rtnlist] = array('fcb'=>'rtnlist','next'=>-1,'cur'=>0,'items'=>$items,'count'=>$cnt);

         }
         break;

      }
 
      return true;

    }

    return false;

  }
/* }}} */

  function system($val) /* {{{ */
  {

    $res = '';
    $this->use_queries("/SYSTEM".SB.$val,$res);
    return $res;

  }
/* }}} */

  function iconv($str, $conv) /* {{{ */
  {

    $res = '';
    $this->use_queries("/ICONV".SB.$str.SB.$conv,$res);
    return $res;

  }
/* }}} */

  function oconv($str, $conv) /* {{{ */
  {
    $res = '';
    return $this->use_queries("/OCONV".SB.$str.SB.$conv,$res);
    return $res;

  }
/* }}} */

  function call($sub,$args = null)  /* {{{ */
/*
  call a subroutine on the server
  args, if supplied, must be an array of arguments
  which can optionally be call by reference (with preceding &)
  use this array to determine count and signature
  NOTE: arrays are pick arrays (ie, [0] is blank and data starts at [1])
        use the MAT routines to construct and manipulate them
*/
  {
    $sign = array();

    if ($args !== null)
      foreach($args as $arg)
        if (is_array($arg)) $sign[] = 'A'.INMAT($arg); else $sign[] = 'S';

    $n = count($sign); // number of args
    $sign = implode(',',$sign);
    if (strpos($sign,'A') === false) $sign = ''; // no signature needed if no arrays

// build path from sub, signature, and acct (if needed)
    $path = $sub;
    $p = strpos($path,' '); // file sub
    $q = strpos($path,','); // acct,file, sub

    if ($p !== false && $q === false) 
      $path = $this->acct.','.substr($path,0,$p).' '.substr($path,$p+1);
    else if ($sign)
      $path = "{$this->acct} $sub";

    if ($sign) 
      $call = "/CALLEX".SB.$path.SB.$sign; 
    else
      $call = "/CALL".SB.$path.SB.$n;

    foreach($args as $arg)
      if (is_array($arg)) 
        $call .= SB.MATBUILD($arg); // make string out of array
      else
        $call .= SB.$arg;

    if ($this->use_queries($call,$res)) {

      $res = explode(SB,$res);

      for ($i=0; $i<$n; $i++)
        if (is_array($args[$i]))
          $args[$i] = MATPARSE($res[$i]);
        else
          $args[$i] = $res[$i];

      return true;
    }

    return false; // call failed

  }
/* }}} */

  function lock($lock, $val)  /* {{{ */
  {

    if ($lock) {
      $ret = $this->use_queries("/LOCK".SB.$val,$res);
      if ($ret && $res) $this->locks[$val] = $val;
    } else {
      $ret = $this->use_queries("/UNLOCK".SB.$val,$res);
      if ($ret && $res) unset($this->locks[$val]);
    }
 
    return $res;
  }
/* }}} */

  function next_group($sel) /* {{{ */
  {

    while ($this->selects[$sel]['next'] >= 0) {

      $this->init(3,RP_SEQIDS);
      $this->prot0 = $this->selects[$sel]['fcb'];
      $this->arg0 = $this->selects[$sel]['next'];

      if (!$this->send()) return false;
      if (!$this->get($tmp)) return false;

      if ($this->rtncd & 0x80000000) {
        $this->selects[$sel]['next'] = -1; // end of list
        return false;
      } else
        $this->selects[$sel]['next'] = $this->rtncd;

      if ($this->bfsz > 2) {
        $this->selects[$sel]['items'] = explode(AM,substr($tmp,1,$this->bfsz - 3));
        $this->selects[$sel]['cur'] = 0;
        $this->selects[$sel]['count'] = count($this->selects[$sel]['items']);
        return true;
      }

    }

    return false;
  
  }
/* }}} */

  function select($fd, &$sel) /* {{{ */
  {

    if ($fd < 0) return false;
    else if (!isset($this->files[$fd])) return false;
    else if ($this->files[$fd] === null) return false;

    $sel = $this->select_count++;
    $this->selects[$sel] = array('fcb'=>$this->files[$fd]['fcb'],'next'=>0,'cur'=>0,'items'=>array(),'count'=>0);
    return $this->next_group($sel);

  }
/* }}} */

  function readnext(&$id, &$sel, &$val = null)  /* {{{ */
  {

    if ($sel < 0) return false;
    else if (!isset($this->selects[$sel])) return false;
    else if ($this->selects[$sel] === null) return false;

    do {
      if ($this->selects[$sel]['cur'] < $this->selects[$sel]['count']) {

        $id = $this->selects[$sel]['items'][$this->selects[$sel]['cur']++];

        if ($val !== null) {
          $tmp = explode(VM,$id);
          $val = hexdec($tmp[1]);
          $id = $tmp[0];
        }

        return true;
      }
    } while ($this->next_group($sel));

    return false;
  }
/* }}} */

  function clearselect($sel) /* {{{ */
  {

    if ($sel < 0) return false;
    else if (!isset($this->selects[$sel])) return false;
    else if ($this->selects[$sel] === null) return false;

    $this->selects[$sel] = null;

    return true;

  }
/* }}} */

  function root($file, $corr, &$sel) /* {{{ */
  {

    if (!$this->open(0,$file,$fd)) return false;

    $this->init(1,RP_OPEN);
    $this->prot0 = $this->files[$fd]['fcb'];
    $this->arg0 = RP_OPENINDX;
    $this->append(NIL,$corr,SM);

    if ($this->send())
      if ($this->get($tmp))
        if ($this->rtncd == RP_OK) {
          $sel = $this->indexes_count++; 
          $this->indexes[$sel] = array('fcb'=>$this->prot0,'cur'=>0);
          return true;
        }

    return false;
  }
/* }}} */

  function closeroot($sel) /* {{{ */
  {
    if ($sel < 0) return false;
    else if (!isset($this->indexes[$sel])) return false;
    else if ($this->indexes[$sel] === null) return false;

    $this->indexes[$sel] = null;

    return true;
  }
/* }}} */

  function key($mode, $root, &$key, &$id, &$val = null)  /* {{{ */
  {

    if ($root < 0) return false;
    else if ($mode == '') return false;
    else if (!isset($this->indexes[$root])) return false;
    else if ($this->indexes[$sel] === null) return false;

    $this->init(3,RP_KEY);
    $this->prot0 = $this->indexes[$root]['fcb'];
    $this->arg0 = $this->indexes[$root]['cur'];
    if ($val !== null) $this->arg0 = $val;

    if (!$this->indexes[$root]['cur']) {
      $id = '';
      $this->indexes[$root]['cur'] = 1;
    }

    $this->arg2 = 0x40ff0080; 
    $this->append($mode,$key,AM);
    if (id !== null) $this->append(id);
    $this->append(SM);

    if ($this->send())
      if ($this->get($tmp)) {

        if ($this->rtncd & 0x80000000) return false; // not found or some other error

        if ($val !== null) $val = $this->rtncd;

        $key = '';
        $id = '';
        $first = true;

        for ($i=3; $i<$this->bfsz; $i++)
          if ($tmp[$i] == SM)
            $first = !$first;
          else if ($first)
            $key .= $tmp[$i];
          else
            $id .= $tmp[$i];

        return true;

      }

    return false;
  
  }
/* }}} */

  
};

class PickNFS_SSL extends PickNFS
{
  var $verify_peer;
  var $allow_self_signed;
  var $pem; // key, cert, and any ca bundle in one file if client is required to send cert
  var $ca; // could be file or directory to verify a server cert
 
  function __construct($host, $port, $verify_peer = false, $allow_self_signed = true, $pem = null, $ca = null) { /* {{{ */

    if (!extension_loaded('openssl')) die('openssl module required');
    PickNFS::__construct($host, $port);
    $this->secure = true;

    $this->verify_peer = $verify_peer;
    $this->allow_self_signed = $allow_self_signed;
    $this->pem = $pem;
    $this->ca = $ca;

  }
/* }}} */

  function connect($user=null, $pass=null, $acct=null, $apsw=null) { /* {{{ */

    if ($this->sock === null) {
      $opts = array();
      $opts['verify_peer'] = $this->verify_peer;
      $opts['verify_peer_name'] = $this->verify_peer;
      $opts['allow_self_signed'] = $this->allow_self_signed;

      if ($this->ca !== null) {

        if (is_file($this->ca))
          $opts['cafile'] = $this->ca; 
        else if (is_dir($this->ca))
          $opts['capath'] = $this->ca;
        else
          echo "Warning: $this->ca is not a legal CA\n";

      }

      if ($this->pem !== null) {

        if (is_file($this->pem))
          list($opts['local_cert'],$opts['local_pk']) = array($this->pem,$this->pem);
        else
          echo "Warning: $this->pem is not a valid path\n";

      }

      $ctx = stream_context_create(array('ssl'=>$opts));
      $this->sock = stream_socket_client("ssl://$this->host:$this->port",$errno,$errstr,30,STREAM_CLIENT_CONNECT,$ctx);
      if (!$this->sock) die("SSL connect error: ($errno) $errstr\n");

    }

    if (!$this->sock) return false;

    $this->user = $user.AM.$user;
    $this->host = $this->host.VM.$this->port.VM.VM.'15'.SM;
    $this->acct = $acct;

    $this->connected = true;
    $login = false;
    $this->set_timeout(30,30);

    if ($user === null && $pass === null && $acct === null && $apsw === null) {
      $this->user = 'DM';
      $this->acct = 'DM';
      return true;
    }

    $this->open(0,TRIGGERFILE,$this->queries) or die(TRIGGERFILE." file not found\n");

    $this->use_queries("/LOGIN\xfb$user\xfb$pass\xfb$acct\xfb$apsw",$tmp) or die("PICKNFS: queries could not be processed\n");
    if ($tmp != '')
      list($this->pib,$login) = array($tmp,true);

    return $login;

  }
/* }}} */
}

?>
