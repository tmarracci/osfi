SUBROUTINE (V)
*
* TRIGGER TO PERFORM PICKNFS RPC THAT CANNOT BE EXECUTED DIRECTLY
*
  IF V[1,1]#'/' THEN RETURN
  IF ACCESS(12) THEN RETURN
*
* PROCESS COMMANDS FROM REMOTE PHP USER
* UTILIZING PICKNFS
* CERTAIN FEATURES ARE NOT AVAILBLE IN PICKNFS
* THAT WERE SUPPORTED BY D3PIPES, SO WE'RE USING
* THE QUERIES FUNCTIONALITY INSTEAD
* WE USE CHAR(251) (SB) AS A DELIMITER
* THE COMMAND IS FIRST, FOLLOWED BY ANY PARAMETERS
* THE RESULT IS THEN WRITTEN BACK TO THE QUERIES FILE
* FOR PICKUP BY THE REMOTE CALLER. BECAUSE WE'RE USING
* A TRIGGER, CERTAIN ENVIRONMENT DETAILS ARE NOT AVAILABLE
* SO DON'T RELY ON NAMED COMMON OR EXISTING SELECT LISTS
  QID = ACCESS(10)
  PIB = SYSTEM(22)
  IF V[LEN(V),1] = CHAR(10) THEN V = V[1,LEN(V)-1]
  CMD = FIELD(V,CHAR(251),1)
  BEGIN CASE
    CASE CMD='/LOGIN'
* VERIFY CREDENTIALS
* LOG TO SPECIFIC ACCOUNT IF SUCCESSFUL
* AND RETURN THE PIB OF THIS PROCESS
      USER = FIELD(V,CHAR(251),2)
      UPSW = FIELD(V,CHAR(251),3)
      ACCT = FIELD(V,CHAR(251),4)
      APSW = FIELD(V,CHAR(251),5)
      OPEN 'USERS' TO USERS THEN
        READ REC FROM USERS,USER THEN
          OK = (REC<7>:UPSW = '')
          IF NOT(OK) THEN LOCATE OCONV(UPSW,'U3060') IN REC<7> SETTING OK ELSE OK = 0
          IF OK THEN
            OK = 0
            OPEN 'MDS,,' TO MDS THEN
              READ REC FROM MDS,ACCT THEN
                OK = (REC<7>:APSW = '')
                IF NOT(OK) THEN LOCATE OCONV(APSW,'U3060') IN REC<7> SETTING OK ELSE OK = 0
                IF OK THEN
                  IF APSW#'' THEN DATA APSW
                  EXECUTE 'LOGTO ':ACCT:' (F)'
                END
              END
            END
          END
        END
      END
      IF OK THEN V = PIB ELSE V = ''
    CASE CMD='/LOGTO'
      ACCT = FIELD(V,CHAR(251),2)
      APSW = FIELD(V,CHAR(251),3)
      V = 0
      OPEN 'MDS,,' TO MDS THEN
        READ MREC FROM MDS,ACCT THEN
          IF MREC<7>='' AND APSW='' THEN
            EXECUTE 'LOGTO ':ACCT:' (F)'
            V = 1
          END ELSE LOCATE OCONV(APSW,'U3060') IN MREC<7> SETTING P THEN
            EXECUTE 'LOGTO ':ACCT:' (F)' STACKING APSW
            V = 1
          END
        END
      END
    CASE CMD='/ICONV'
      STR = FIELD(V,CHAR(251),2)
      CORR = FIELD(V,CHAR(251),3)
      V = ICONV(STR,CORR)
    CASE CMD='/OCONV'
      STR = FIELD(V,CHAR(251),2)
      CORR = FIELD(V,CHAR(251),3)
      V = OCONV(STR,CORR)
    CASE CMD='/SYSTEM'
      N = FIELD(V,CHAR(251),2)
      IF N MATCHES '1N0N' THEN V = SYSTEM(N) ELSE V=''
    CASE CMD='/EXECUTE'
      EXECUTE FIELD(V,CHAR(251),2) CAPTURING V
      IF SYSTEM(11) THEN EXECUTE 'SAVE-LIST ':QID
    CASE CMD='/EXECUTE2'
* V[1] = /EXECUTE2
* V[2] = TCL CMD
* V[3] = LIST ITEMS (IF ANY)
      TCL = FIELD(V,CHAR(251),2)
      IF DCOUNT(V,CHAR(251)) = 3 THEN
        PASS = FIELD(V,CHAR(251),3)
        SELECT PASS TO ITEMS
        EXECUTE TCL PASSLIST ITEMS RETURNING RET CAPTURING CAP
      END ELSE
        EXECUTE TCL RETURNING RET CAPTURING CAP
      END
      V = RET:CHAR(251):CAP
      IF SYSTEM(11) THEN
        OPEN 'POINTER-FILE' TO PFILE
        EXECUTE 'SAVE-LIST ':QID CAPTURING X
        READ ITEMS FROM PFILE,QID ELSE ITEMS=''
        V := CHAR(251):ITEMS
        DELETE PFILE,QID
      END
    CASE CMD='/CALL'
      SUB = FIELD(V,CHAR(251),2)
      SIGN = ''
      GOSUB VALIDATE.D3.CALL
      IF ERR#'' THEN EXECUTE 'LOG-MSG ':ERR
      N = FIELD(V,CHAR(251),3)+0
      IF N#ARGS AND ERR='' THEN ERR=SUB:' DOESNT TAKE ':N:' PARAMETERS'; EXECUTE 'LOG-MSG ':ERR
      IF N THEN
        DIM PARAM(N)
        FOR I = 1 TO N
          PARAM(I) = FIELD(V,CHAR(251),3+I)
        NEXT I
        IF ERR='' THEN
          BEGIN CASE
            CASE N=1; CALL @SUB(PARAM(1))
            CASE N=2; CALL @SUB(PARAM(1),PARAM(2))
            CASE N=3; CALL @SUB(PARAM(1),PARAM(2),PARAM(3))
            CASE N=4; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4))
            CASE N=5; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5))
            CASE N=6; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5),PARAM(6))
            CASE N=7; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5),PARAM(6),PARAM(7))
            CASE N=8; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5),PARAM(6),PARAM(7),PARAM(8))
            CASE N=9; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5),PARAM(6),PARAM(7),PARAM(8),PARAM(9))
            CASE N=10; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5),PARAM(6),PARAM(7),PARAM(8),PARAM(9),PARAM(10))
            CASE N=11; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5),PARAM(6),PARAM(7),PARAM(8),PARAM(9),PARAM(10),PARAM(11))
            CASE N=12; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5),PARAM(6),PARAM(7),PARAM(8),PARAM(9),PARAM(10),PARAM(11),PARAM(12))
            CASE N=13; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5),PARAM(6),PARAM(7),PARAM(8),PARAM(9),PARAM(10),PARAM(11),PARAM(12),PARAM(13))
            CASE N=14; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5),PARAM(6),PARAM(7),PARAM(8),PARAM(9),PARAM(10),PARAM(11),PARAM(12),PARAM(13),PARAM(14))
            CASE N=15; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5),PARAM(6),PARAM(7),PARAM(8),PARAM(9),PARAM(10),PARAM(11),PARAM(12),PARAM(13),PARAM(14),PARAM(15))
            CASE N=16; CALL @SUB(PARAM(1),PARAM(2),PARAM(3),PARAM(4),PARAM(5),PARAM(6),PARAM(7),PARAM(8),PARAM(9),PARAM(10),PARAM(11),PARAM(12),PARAM(13),PARAM(14),PARAM(15),PARAM(16))
          END CASE
        END
        V = ''
        FOR I = 1 TO N
          IF I > 1 THEN V := CHAR(251)
          V := PARAM(I)
        NEXT I
      END ELSE
        IF ERR='' THEN CALL @SUB
        V = ''
      END
    CASE CMD='/CALLEX'
      GOSUB CALLEX
      IF ERR#'' THEN EXECUTE 'LOG-MSG ':ERR
    CASE CMD='/PRINT'
      PRINTER ON
      FOR I = 2 TO DCOUNT(V,CHAR(254))
        PRINT V<I>
      NEXT I
      V='0'
      PRINTER CLOSE
      PRINTER OFF
    CASE CMD='/LOCK'
      N = FIELD(V,CHAR(251),2)
      V = 0
      IF N#'' AND N MATCHES '0N' AND N < 64 THEN LOCK N THEN V=1
    CASE CMD='/UNLOCK'
      N = FIELD(V,CHAR(251),2)
      V = 0
      IF N AND N MATCHES '0N' AND N < 64 THEN UNLOCK N; V=1
    CASE 1
      V = ''
  END CASE
  RETURN
VALIDATE.D3.CALL:
* VALIDATE SUBROUTINE CALL
* SUB IS NAME OF SUBROUTINE
* ERR IS SET IF THERE IS AN ERROR
* ARGS IS NUMBER OF ARGUMENTS REQUIRED
*
  ERR=''
  ARGS = 0
  IF NOT(INDEX(SUB,' ',1)) THEN
    OPEN 'MD' TO MD THEN
      READ MDREC FROM MD,SUB THEN
        IF MDREC<1>='VR' THEN SUB = MDREC<4>
      END
    END
  END
  IF INDEX(SUB,' ',1) THEN
    PATH = FIELD(SUB,' ',1)
    PROG = FIELD(SUB,' ',2)
    IF INDEX(PATH,',',1) THEN
      OPEN PATH TO SRCFILE THEN
        READV SRC FROM SRCFILE,PROG,1 THEN
          SRC=TRIM(SRC)
          IF SRC[1,3]='SUB' THEN
            IF INDEX(SRC,'(MAT ',1)+INDEX(SRC,',MAT ',1)+INDEX(SRC,'( MAT ',1)+INDEX(SRC,', MAT ',1)=0 THEN
              IF INDEX(SRC,'(',1) THEN
                ARGS = DCOUNT(SRC,',')
              END ELSE
                ARGS = 0
              END
            END ELSE IF SIGN # '' THEN
              ARGLIST = TRIM(FIELD(FIELD(SRC,'(',2),')',1))
              ARGS = DCOUNT(ARGLIST,',')
              FOR I = 1 TO ARGS WHILE ERR=''
                ARG = TRIM(FIELD(ARGLIST,',',I))
                SIG = FIELD(SIGN,',',I)
                IF SIG='' THEN
                  ERR = SUB:' ARGUMENT COUNT MISMATCH'
                END ELSE IF FIELD(ARG,' ',1)='MAT' THEN
                  IF SIG[1,1]#'A' THEN ERR = SUB:' ARRAY EXPECTED'
                END ELSE
                  IF SIG[1,1]='A' THEN ERR = SUB:' STRING VARIABLE EXPECTED'
                END
              NEXT I
            END ELSE
              ERR=SUB:' REFERENCES DIMENSIONED ARGUMENTS'
            END
          END ELSE
            ERR=SUB:' MUST BE A SUBROUTINE'
          END
        END ELSE
          ERR=SUB:' IS NOT ON FILE'
        END
      END ELSE
        ERR=PATH:' COULD NOT BE OPENED'
      END
      SRC = TRIM(SRC)
    END ELSE
      ERR=SUB:' MUST REFER TO A FULL PATH NAME'
    END
  END ELSE
    ERR=SUB:' MUST INCLUDE THE PATH NAME TO SOURCE'
  END
  RETURN
CALLEX:
  SUB = FIELD(V,CHAR(251),2)
  IF INDEX(SUB,' ',1) THEN
    IF NOT(INDEX(FIELD(SUB,' ',1),',',1)) THEN
* ACCT SUBNAME
* LOOKUP IN MD FOR FULL PATH
* CONSTRUCT AS NEEDED PRIOR TO VERIFICATION
      ACCT = FIELD(SUB,' ',1)
      NAME = FIELD(SUB,' ',2)
      OPEN ACCT:',MD,' TO MD THEN
        READ VR FROM MD,NAME THEN IF VR<1> = 'VR' THEN
          PATH = VR<4>
          IF NOT(INDEX(FIELD(PATH,' ',1),',',1)) THEN
            PATH = ACCT:',':FIELD(PATH,' ',1):', ':FIELD(PATH,' ',2)
          END
          SUB = PATH
        END
      END
    END
  END
  SIGN = FIELD(V,CHAR(251),3)
  GOSUB VALIDATE.D3.CALL
  IF ERR#'' THEN RETURN
  N = DCOUNT(SIGN,',')
  IF N # ARGS THEN
* SHOULD ALREADY MATCH FROM PRIOR ANALYSIS
    ERR = 'PARAMETER COUNT MISMATCH ':SUB
    RETURN
  END
*
* PICKNFS CALLEX - CONSTRUCT CODE IN PLACE TO MAKE EXTERNAL CALLS
* USING SIGNATURE PROVIDED
* IF SUBROUTINE ALREADY CONSTUCTED, USE IT
* OTHERWISE MAKE A NEW ONE NOW
* AND COMPILE IT FOR USE BY PICKNFS
* NOTE FLASH IF USED TO COMPILE WITH FLASH OPTION
*
* FROM SIGNATURE, MAKE BINARY REP OF STRING/ARRAY ARGUMENTS
* CONVERT TO HEX AND MAKE A SUBROUTINE NAME
* IF IT EXISTS IN MD, USE IT
* OTHERWISE, CONSTRUCT NEW SOURCE THAT TAKES A TWO ARGUMENTS (SUB,V)
* DIMS ARRAYS AS NEEDED (CAN BE LOCAL STACK ARRAYS IN THIS CASE)
* MARSHALLS DATA FROM V INTO STRING AND ARRAY PARAMS
* PERFORM THE CALL
* THEN MARSHALL DATA BACK OUT TO V
* AND RETURN
  IF N < 1 THEN
    CALL @SUB
    V = ''
    RETURN
  END
  OPEN 'DM,BP,' TO BP ELSE
    ERR='DM,BP, MISSING'
    RETURN
  END
  DIM TSIGN(N)
  MATPARSE TSIGN FROM SIGN USING ','
  BN = 0
  FOR I = 1 TO N
    BN *= 2
    IF TSIGN(I)[1,1]='A' THEN BN += 1
  NEXT I
  PNAME = 'PICKNFS.CALLEX.':N:'.':DTX(BN)
  PSUB = 'DM,BP, ':PNAME
  READV TMP FROM BP,PNAME,1 ELSE
* 100 SHOULD BE MORE THAN ENOUGH
* MAX SOURCE LENGTH IS 7 + 3 * N
* THE MAXIMUM SIZE WITH 16 ARRAY ARGS IS 55 LINES
    DIM NSRC(100)
    MAT NSRC = ''
    P = 0
    L = 'SUBROUTINE (SUB,V)'; GOSUB ADD.SRC
    L = 'DIM ARGS(':(N+3):')'; GOSUB ADD.SRC
    L = 'MATPARSE ARGS FROM V USING CHAR(251)'; GOSUB ADD.SRC
    BCALL = 'CALL @SUB('
    FOR I = 1 TO N
      IF I>1 THEN BCALL := ','
      IF TSIGN(I) = 'S' THEN
        BCALL := 'ARGS(':(I+3):')'
      END ELSE IF TSIGN(I)[1,1]='A' THEN
        L = 'DIM A':I:'(':TSIGN(I)[2,999]:')'; GOSUB ADD.SRC
        L = 'MATPARSE A':I:' FROM ARGS(':(I+3):')'; GOSUB ADD.SRC
        BCALL := 'MAT A':I
      END ELSE
        ERR='ILLEGAL SIGNATURE'
        RETURN
      END
    NEXT I
    BCALL := ')'
    L = BCALL; GOSUB ADD.SRC
    FOR I = 1 TO N
      IF TSIGN(I)[1,1]='A' THEN
        L = 'MATBUILD ARGS(':(I+3):') FROM A':I; GOSUB ADD.SRC
      END
    NEXT I
    L = 'MATBUILD V FROM ARGS,4,':(N+3):' USING CHAR(251)'; GOSUB ADD.SRC
    L = 'RETURN'; GOSUB ADD.SRC
    L = 'END'; GOSUB ADD.SRC
    WRITE NSRC ON BP,PNAME
    CMD = 'COMPILE-CATALOG DM,BP, ':PNAME
    IF SYSTEM(36) THEN CMD := ' (O'; * FLASH
    EXECUTE CMD CAPTURING X
  END
  CALL @PSUB(SUB,V)
  RETURN
ADD.SRC:
  P += 1
  NSRC(P) = L
  RETURN
END